% The purpose of this analysis is to determine the phase speed of low mode
% waves using a 1D taylor goldstein analysis. We use Bill Smyths FG method
% code.

% PARAMS
% density of interface top
sig4i = 1045.93;  % double check this matches the choice in other analysis.
%sig4i_ = 1045.93;
% Turbulent diffusivity (if constant)
% Kv0 = 1e-2;
% To smooth profiles or not? Maybe diffusivity takes care of this?
dosmoothing = true;
% Smoothing amounts
zlp = 10;  % low pass wavelength in m
zd = 1;  % sampling wavelength in m
Np = zlp/zd;  % number of data points per wavelength
mlp = 1/zlp;  % filter wavenumber cpm
ms = 1/zd;  % sampling wavenumber cpm
% horizontal wavenumber and range of angles for Taylor Goldstein
kh = 1e-8;
dang = pi/6;
angles = 0:dang:pi-dang;
% Compute all modes (imode=1 gives fastest-growing unstable mode)
imode = 0;
% Number of modes to save
nmsave = 4;
% Skip some data to increase speed
step = 5;
% Order of the derivative
dorder = 3;
% Mixing efficiency
gamma = 0.2;
% Max data required in a profile
ndatamax = 10*step;
% END PARAMS

% LOAD DATA
% This data file is generated by the script 'stack_towyos.py'.
data_file = "../proc_data/stacked_towyos.nc";
u_ = ncread(data_file, "u");
v_ = ncread(data_file, "v");
b_ = ncread(data_file, "b_sorted");
z_ = ncread(data_file, "z");
sig4_ = ncread(data_file, "sig4_sorted");
pfl = ncread(data_file, "pfl");
eps_ = ncread(data_file, "eps");
N2_ref_ = ncread(data_file, "N2_ref");

[npfl, ~] = size(pfl);

cp_us = nan*ones(npfl, nmsave, length(angles));  % upstream
cp_ds = nan*ones(npfl, nmsave, length(angles));  % downstream

for idx = 1:npfl
    
    % clean up data and remove data above the interface
    u = u_(idx, :);
    v = v_(idx, :);
    sig4 = sig4_(idx, :);
    b = b_(idx, :);
    eps = eps_(idx, :);
    N2_ref = N2_ref_(idx, :);

    use = ~isnan(b) & ~isnan(u) & ~isnan(v) & (sig4 > sig4i);

    % also make everything a column vector... erugh matlab
    u = u(use)';
    v = v(use)';
    sig4 = sig4(use)';
    b = b(use)';
    eps = eps(use)';
    N2_ref = N2_ref(use)';
    z = z_(use);
    
    [ndata, ~] = size(b);
    if ndata < ndatamax
        continue
    end
    
    % fill with background epsilon
    eps(isnan(eps)) = 6e-11;

    % legacy from old rotate code
    up = u;
    vp = v;

    Mdiff = BaryL(z, 1, dorder);  % This is the differentiation matrix.

    % Smooth data
    if dosmoothing
        us = lowpass(up, mlp, ms, 'ImpulseResponse', 'iir');
        vs = lowpass(vp, mlp, ms, 'ImpulseResponse', 'iir');
        bs = lowpass(b, mlp, ms, 'ImpulseResponse', 'iir');
        sig4s = lowpass(sig4, mlp, ms, 'ImpulseResponse', 'iir');
        bz = Mdiff*bs;
        zs = z;
        % Filter ringing at ends means we should cut off ends.
    %     us = us(1 + Np/2:end - Np/2);
    %     bs = bs(1 + Np/2:end - Np/2);
    %     sig4s = sig4s(1 + Np/2:end - Np/2);
    %     bz = bz(1 + Np/2:end - Np/2);
    %     zs = zs(1 + Np/2:end - Np/2);
    else
        us = up;
        vs = vp;
        bs = b;
        sig4s = sig4;
        bz = Mdiff*bs;
        zs = z;

    end
    
    % Diffusivity profile
    Kvs = gamma*eps./N2_ref;
%     Kv = Kv0*ones(size(b));
%     Kv(sig4 < sig4i_) = 1e-4;

    % cut out some data for speed
    us = us(1:step:end);
    vs = vs(1:step:end);
    sig4s = sig4s(1:step:end);
    bs = bs(1:step:end);
    bz = bz(1:step:end);
    zs = zs(1:step:end);
    Kvs = Kvs(1:step:end);
    N2_refs = N2_ref(1:step:end);
    epss = eps(1:step:end);

    % Other diffusivity/viscosity params
    Khs = Kvs;
    Avs = Kvs;
    Ahs = Kvs;
    
    for iang = 1:length(angles)
        
        ang = angles(iang);
        
        k = kh*cos(ang);
        l = kh*sin(ang);

        message = sprintf('Index = %d, angle = %1.1f k = %e, l = %e', idx, rad2deg(ang), k, l);
        disp(message)

        %%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Use Fourier-Galerkin method to compute growth rates & eigfns
        % Compute Fourier integrals in advance
        FG = vTG_FGprep(zs, us, vs, N2_refs, Avs, Ahs, Kvs, Khs); 
        % Compute growth rates & eigfns
        [om, we, be] = vTG_FG(zs, us, vs, Avs, Ahs, k, l, imode, FG);
        % read above as returning
        % [frequency, w eigenvector, b eigenvector]

        % phase speed
        cp = -om/kh;
        % sort by phase speed
        [cp, ind] = sort(cp, 'ascend');
        we = we(:, ind);
        be = be(:, ind);
        om = om(ind);
        % horizontal velocity eigenfunction
        ue = (1i/kh)*BaryL(zs, 1, dorder)*we;

        cp_us(idx, :, iang) = cp(1:nmsave);
        cp_ds(idx, :, iang) = cp(end-nmsave+1:end);

        fname = sprintf('FGTG_p%04d_a%03d.mat', idx, int16(rad2deg(ang)));
        disp("Saving " + fname)
        info = ["cp: phase speed", "we: w eigenvectors", "be: b eigenvectors", ...
            "om: frequency", "ue: u eigenvectors", "sig4i: interface density", ...
            "dosmoothing: true if smoothed", "zlp: low pass wavelength", "k: x wavevector", "l: y wavevector", ...
            "step: step for coarsening data", "us: velocity profile", "bs: buoyancy profile", ...
            "bz: gradient of buoyancy" "sig4s: density profile", "Kvs: diffusivity profile", ...
            "zs: depth", "idx: profile number in stacked towyos file", "epss: TKE dissipation", ...
            "N2_refs: buoyancy frequency squared adiabatically levelled"];
        save(strcat("../proc_data/", fname), "info", "cp", "we", "be", "om", ...
            "ue", "sig4i", "dosmoothing", "zlp", "k", "l", "step", "us", "bs", "bz", ...
            "sig4s", "Kvs", "zs", "idx", "epss", "N2_refs")

    end
    
end

save("../proc_data/TG_phase_speed.mat", "cp_us", "cp_ds", "angles", "kh")

