% The purpose of this analysis is to determine the phase speed of low mode
% waves using a 1D taylor goldstein analysis. 

% PARAMS
% density of interface top
sig4i = 1045.93;  % double check this matches the choice in other analysis.
% Turbulent diffusivity (if constant)
Kv0 = 1e-2;
% To smooth profiles or not? Maybe diffusivity takes care of this?
dosmoothing = false;
% Smoothing amounts
bspan = 0.1;
vspan = 0.3;
% wavenumber for Taylor Goldstein
L = 100000;
k = 2*pi/L;
% Compute all modes (imode=1 gives fastest-growing unstable mode)
imode = 0;
% Skip some data to increase speed
step = 5;
% Order of the derivative
dorder = 3;
% END PARAMS

% LOAD DATA
% This data file is generated by the script 'stack_towyos.py'.
data_file = "../proc_data/stacked_towyos.nc";
u_ = ncread(data_file, "u");
v_ = ncread(data_file, "v");
b_ = ncread(data_file, "b_sorted");
z_ = ncread(data_file, "z");
sig4_ = ncread(data_file, "sig4_sorted");
lon = ncread(data_file, "lon");
lat = ncread(data_file, "lat");
pfl = ncread(data_file, "pfl");

[npfl, ~] = size(pfl);
cps = nan*ones(size(pfl));
angles = nan*ones(size(pfl));
% ues
% wes

for idx = 1:npfl

    % clean up data and remove data above the interface
    u = u_(idx, :);
    v = v_(idx, :);
    sig4 = sig4_(idx, :);
    b = b_(idx, :);

    use = ~isnan(b) & ~isnan(u) & ~isnan(v) & (sig4 > sig4i);

    % also make everything a column vector... erugh matlab
    u = u(use)';
    v = v(use)';
    sig4 = sig4(use)';
    b = b(use)';
    z = z_(use);
    
    if isempty(u)
        continue
    end
    
    if length(u) <= dorder
        continue
    end

    % cut out some data for speed
    u = u(1:step:end);
    v = v(1:step:end);
    sig4 = sig4(1:step:end);
    b = b(1:step:end);
    z = z(1:step:end);

    % rotate the velocity into the depth mean direction
    dz = 1*step;  % this is the bin size of each data point.
    U = sum(u*dz)/sum(dz*use);
    V = sum(v*dz)/sum(dz*use);
    % need the - and 2*pi because atan2 returns values in the range [-pi, pi]
    % and we want [0, 2*pi]
    angle = -atan2(V, U) + 2*pi;
    angles(idx) = angle;
    up = u*cos(angle) - v*sin(angle);
    vp = u*sin(angle) + v*cos(angle);
    % after doing the above, up should contain all the depth mean velocity.

    %%%%%%% Taylor Goldstein analysis in the U direction

    Mdiff = BaryL(z, 1, dorder);  % This is the differentiation matrix.

    % Smooth data
    if dosmoothing
        us = smooth(z, up, vspan, 'rloess');
        bs = smooth(z, b, bspan, 'rloess');
        bz = Mdiff*bs;
    else
        us = up;
        bs = b;
        bz = Mdiff*bs;
    end

    % Diffusivity profile
    % kv = gamma*eps./bzs.^2;
    [nz, ~] = size(bs);
    Kv = Kv0*ones(nz, 1);
    Kh = Kv;
    Av = Kv;
    Ah = Kv;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Use Fourier-Galerkin method to compute growth rates & eigfns
    % Compute Fourier integrals in advance
    FG = vTG_FGprep(z, us, 0*us, bz, Av, Ah, Kv, Kh); 
    % Compute growth rates & eigfns
    [om, we, be] = vTG_FG(z, us, 0*us, Av, Ah, k, 0, imode, FG);
    % read above as returning
    % [frequency, w eigenvector, b eigenvector]

    % phase speed (I don't understand why this minus is there)
    cp = -imag(om)/k;
    % sort by phase speed
    [cp, ind] = sort(cp,'ascend');
    we = we(:, ind);
    be = be(:, ind);
    om = om(ind);
    % horizontal velocity eigenfunction
    ue = (1i/k)*Mdiff*we;
    
    cps(idx) = cp(1);

end

save("../proc_data/TG_phase_speed.mat", "cps", "angles")

