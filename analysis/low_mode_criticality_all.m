% The purpose of this analysis is to determine the phase speed of low mode
% waves using a 1D taylor goldstein analysis. We use Bill Smyths FG method
% code.

% PARAMS
% density of interface top
sig4i = 1045.93;  % double check this matches the choice in other analysis.
%sig4i_ = 1045.93;
% Turbulent diffusivity (if constant)
% Kv0 = 1e-2;
% To smooth profiles or not? Maybe diffusivity takes care of this?
dosmoothing = true;
% Smoothing amounts
zlp = 10;  % low pass wavelength in m
zd = 1;  % sampling wavelength in m
Np = zlp/zd;  % number of data points per wavelength
mlp = 1/zlp;  % filter wavenumber cpm
ms = 1/zd;  % sampling wavenumber cpm
% wavenumber for Taylor Goldstein
L = 100000;
k = 0; %2*pi/L;
l = 2*pi/L;
% Compute all modes (imode=1 gives fastest-growing unstable mode)
imode = 0;
% Number of modes to save
nmsave = 4;
% Skip some data to increase speed
step = 5;
% Order of the derivative
dorder = 3;
% Mixing efficiency
gamma = 0.2;
% Max data required in a profile
ndatamax = 10*step;
% do rotation?
rotate = false;
% END PARAMS

% LOAD DATA
% This data file is generated by the script 'stack_towyos.py'.
data_file = "../proc_data/stacked_towyos.nc";
u_ = ncread(data_file, "u");
v_ = ncread(data_file, "v");
b_ = ncread(data_file, "b_sorted");
z_ = ncread(data_file, "z");
sig4_ = ncread(data_file, "sig4_sorted");
pfl = ncread(data_file, "pfl");
eps_ = ncread(data_file, "eps");
N2_ref_ = ncread(data_file, "N2_ref");

[npfl, ~] = size(pfl);
cp_us = nan*ones(npfl, nmsave);  % upstream
cp_ds = nan*ones(npfl, nmsave);  % downstream
angles = nan*ones(npfl, 1);

for idx = 1:npfl
    disp(idx)
    
    % clean up data and remove data above the interface
    u = u_(idx, :);
    v = v_(idx, :);
    sig4 = sig4_(idx, :);
    b = b_(idx, :);
    eps = eps_(idx, :);
    N2_ref = N2_ref_(idx, :);

    use = ~isnan(b) & ~isnan(u) & ~isnan(v) & (sig4 > sig4i);

    % also make everything a column vector... erugh matlab
    u = u(use)';
    v = v(use)';
    sig4 = sig4(use)';
    b = b(use)';
    eps = eps(use)';
    N2_ref = N2_ref(use)';
    z = z_(use);
    
    [ndata, ~] = size(b);
    if ndata < ndatamax
        continue
    end
    
    % fill with background epsilon
    eps(isnan(eps)) = 6e-11;

    if rotate
        U = sum(u*zd)/sum(zd*use);
        V = sum(v*zd)/sum(zd*use);
        % need the - and 2*pi because atan2 returns values in the range [-pi, pi]
        % and we want [0, 2*pi]
        angle = -atan2(V, U) + 2*pi;
        up = u*cos(angle) - v*sin(angle);
        vp = u*sin(angle) + v*cos(angle);
        angles(idx) = angle;
        % after doing the above, up should contain all the depth mean velocity.
    else
        up = u;
        vp = v;
        angles(idx) = 0;
    end

    Mdiff = BaryL(z, 1, dorder);  % This is the differentiation matrix.

    % Smooth data
    if dosmoothing
        us = lowpass(up, mlp, ms, 'ImpulseResponse', 'iir');
        bs = lowpass(b, mlp, ms, 'ImpulseResponse', 'iir');
        sig4s = lowpass(sig4, mlp, ms, 'ImpulseResponse', 'iir');
        bz = Mdiff*bs;
        zs = z;
        % Filter ringing at ends means we should cut off ends.
    %     us = us(1 + Np/2:end - Np/2);
    %     bs = bs(1 + Np/2:end - Np/2);
    %     sig4s = sig4s(1 + Np/2:end - Np/2);
    %     bz = bz(1 + Np/2:end - Np/2);
    %     zs = zs(1 + Np/2:end - Np/2);

    else
        us = up;
        bs = b;
        sig4s = sig4;
        bz = Mdiff*bs;
        zs = z;

    end
    
    % Diffusivity profile
    Kvs = gamma*eps./N2_ref;
%     Kv = Kv0*ones(size(b));
%     Kv(sig4 < sig4i_) = 1e-4;

    % cut out some data for speed
    us = us(1:step:end);
    % v = v(1:step:end);
    sig4s = sig4s(1:step:end);
    bs = bs(1:step:end);
    bz = bz(1:step:end);
    zs = zs(1:step:end);
    Kvs = Kvs(1:step:end);
    N2_refs = N2_ref(1:step:end);
    epss = eps(1:step:end);

    % Other diffusivity/viscosity params
    Khs = Kvs;
    Avs = Kvs;
    Ahs = Kvs;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Use Fourier-Galerkin method to compute growth rates & eigfns
    % Compute Fourier integrals in advance
    FG = vTG_FGprep(zs, us, 0*us, N2_refs, Avs, Ahs, Kvs, Khs); 
    % Compute growth rates & eigfns
    [om, we, be] = vTG_FG(zs, us, 0*us, Avs, Ahs, k, l, imode, FG);
    % read above as returning
    % [frequency, w eigenvector, b eigenvector]

    % phase speed
    cpk = -imag(om)/k;
    cpl = -imag(om)/l;
    % sort by phase speed
    [cpk, ind] = sort(cpl, 'ascend');
    we = we(:, ind);
    be = be(:, ind);
    om = om(ind);
    % horizontal velocity eigenfunction
    ue = (1i/k)*BaryL(zs, 1, dorder)*we;
    
    cp_us(idx, :) = cpl(1:nmsave);
    cp_ds(idx, :) = cpl(end-nmsave+1:end);
    
    fname = sprintf('FGTG_p%04d.mat', idx);
    info = ["cpk: phase speed in x", "cpl: phase speed in y" "we: w eigenvectors", "be: b eigenvectors", ...
        "om: frequency", "ue: u eigenvectors", "sig4i: interface density", ...
        "dosmoothing: true if smoothed", "zlp: low pass wavelength", "k: wavevector", ...
        "step: step for coarsening data", "us: velocity profile", "bs: buoyancy profile", ...
        "bz: gradient of buoyancy" "sig4s: density profile", "Kvs: diffusivity profile", ...
        "zs: depth", "idx: profile number in stacked towyos file", "epss: TKE dissipation", ...
        "N2_refs: buoyancy frequency squared adiabatically levelled"];
    save(strcat("../proc_data/", fname), "info", "cpk", "cpl", "we", "be", "om", ...
        "ue", "sig4i", "dosmoothing", "zlp", "k", "step", "us", "bs", "bz", ...
        "sig4s", "Kvs", "zs", "idx", "epss", "N2_refs")

end

save("../proc_data/TG_phase_speed.mat", "cp_us", "cp_ds", "angles", "k", "l")

